diff --git a/src/cpu/o3/iew.cc b/src/cpu/o3/iew.cc
index 21b488a..cabd434 100644
--- a/src/cpu/o3/iew.cc
+++ b/src/cpu/o3/iew.cc
@@ -143,6 +143,22 @@ IEW::regProbePoints()
 
 IEW::IEWStats::IEWStats(CPU *cpu)
     : statistics::Group(cpu, "iew"),
+    ADD_STAT(total_forwards_taken, statistics::units::Count::get(),
+             "number of forward branches taken"),
+    ADD_STAT(total_forwards_not_taken, statistics::units::Count::get(),
+             "number of forward branches not taken"),
+    ADD_STAT(total_backwards_taken, statistics::units::Count::get(),
+             "number of backward branches taken"),
+    ADD_STAT(total_backwards_not_taken, statistics::units::Count::get(),
+             "total number of backward branches not taken"),
+    ADD_STAT(mispredicted_forwards_taken, statistics::units::Count::get(),
+             "number of mispredicted forwards taken"),
+    ADD_STAT(mispredicted_forwards_not_taken, statistics::units::Count::get(),
+             "number of mispredicted forwards not taken"),
+    ADD_STAT(mispredicted_backwards_taken, statistics::units::Count::get(),
+             "number of mispredicted backwards taken"),
+    ADD_STAT(mispredicted_backwards_not_taken, statistics::units::Count::get(),
+             "number of mispredicted backwards not taken"),
     ADD_STAT(idleCycles, statistics::units::Cycle::get(),
              "Number of cycles IEW is idle"),
     ADD_STAT(squashCycles, statistics::units::Cycle::get(),
@@ -189,6 +205,7 @@ IEW::IEWStats::IEWStats(CPU *cpu)
     ADD_STAT(wbFanout, statistics::units::Rate<
                 statistics::units::Count, statistics::units::Count>::get(),
              "Average fanout of values written-back")
+
 {
     instsToCommit
         .init(cpu->numThreads)
@@ -1546,6 +1563,62 @@ IEW::updateExeInstStats(const DynInstPtr& inst)
     if (inst->isControl()) {
         cpu->executeStats[tid]->numBranches++;
     }
+    if (inst->isDirectCtrl()) {
+
+        Addr inst_address = inst->pcState().instAddr();
+	    Addr target_address = inst->branchTarget()->instAddr();
+
+       if (inst->readPredTaken()) // branch was predicted taken
+        {
+            // if didn't mispredict, then branch is taken
+            if (inst->mispredicted())
+            {
+                // incriment mispredicted
+                if (target_address > inst_address) {
+                    iewStats.mispredicted_forwards_taken++;
+                    iewStats.total_forwards_not_taken++;
+                }
+                else {
+                    iewStats.mispredicted_backwards_taken++;
+                    iewStats.total_backwards_not_taken++;
+                }
+            }
+            else
+        {
+                // incriment total taken
+                if (target_address > inst_address) {
+                    iewStats.total_forwards_taken++;
+                }
+                else {
+                    iewStats.total_backwards_taken++;
+                }
+            }
+        }
+        else // branch was predicted not taken
+            {
+            // if mispredict, then branch is taken
+            if (inst->mispredicted())
+            {
+                if (target_address > inst_address) {
+                    iewStats.mispredicted_forwards_not_taken++;
+                    iewStats.total_forwards_taken++;
+                }
+                else {
+                    iewStats.mispredicted_backwards_not_taken++;
+                    iewStats.total_backwards_taken++;
+                }
+            }
+            else
+        {
+                if (target_address > inst_address) {
+                    iewStats.total_forwards_not_taken++;
+                }
+                else {
+                    iewStats.total_backwards_not_taken++;
+                }
+            }
+        }
+    }
 
     //
     //  Memory operations
diff --git a/src/cpu/o3/iew.hh b/src/cpu/o3/iew.hh
index 1307e0c..8dcc76a 100644
--- a/src/cpu/o3/iew.hh
+++ b/src/cpu/o3/iew.hh
@@ -422,6 +422,15 @@ class IEW
     {
         IEWStats(CPU *cpu);
 
+        statistics::Scalar total_forwards_taken;
+        statistics::Scalar total_forwards_not_taken;
+        statistics::Scalar total_backwards_taken;
+        statistics::Scalar total_backwards_not_taken;
+        statistics::Scalar mispredicted_forwards_taken;
+        statistics::Scalar mispredicted_forwards_not_taken;
+        statistics::Scalar mispredicted_backwards_taken;
+        statistics::Scalar mispredicted_backwards_not_taken;
+
         /** Stat for total number of idle cycles. */
         statistics::Scalar idleCycles;
         /** Stat for total number of squashing cycles. */
diff --git a/src/cpu/pred/BranchPredictor.py b/src/cpu/pred/BranchPredictor.py
index 47b9852..4ffbf66 100644
--- a/src/cpu/pred/BranchPredictor.py
+++ b/src/cpu/pred/BranchPredictor.py
@@ -228,6 +228,19 @@ class BranchPredictor(SimObject):
     )
 
 
+class GShareBP(BranchPredictor):
+    type = "GShareBP"
+    cxx_class = "gem5::branch_prediction::GShareBP"
+    cxx_header = "cpu/pred/gshare.hh"
+
+    # localPredictorSize is the PHT table size
+    localPredictorSize = Param.Unsigned(2048, "Size of local predictor")
+    # localCtrBits is the number of saturating counter bits
+    localCtrBits = Param.Unsigned(2, "Bits per counter")
+    # globalHistorySize is clobal history length
+    globalHistorySize = Param.Unsigned(2, "gobal history length")
+
+
 class LocalBP(BranchPredictor):
     type = "LocalBP"
     cxx_class = "gem5::branch_prediction::LocalBP"
diff --git a/src/cpu/pred/SConscript b/src/cpu/pred/SConscript
index 6c03dd8..31ce1b6 100644
--- a/src/cpu/pred/SConscript
+++ b/src/cpu/pred/SConscript
@@ -58,11 +58,12 @@ SimObject('BranchPredictor.py',
     'MultiperspectivePerceptronTAGE', 'MPP_StatisticalCorrector_64KB',
     'MultiperspectivePerceptronTAGE64KB', 'MPP_TAGE_8KB',
     'MPP_LoopPredictor_8KB', 'MPP_StatisticalCorrector_8KB',
-    'MultiperspectivePerceptronTAGE8KB'],
+    'MultiperspectivePerceptronTAGE8KB', 'GShareBP'],
     enums=['BranchType', 'TargetProvider'])
 
 Source('bpred_unit.cc')
 Source('2bit_local.cc')
+Source('gshare.cc')
 Source('simple_indirect.cc')
 Source('indirect.cc')
 Source('ras.cc')
diff --git a/src/cpu/pred/gshare.cc b/src/cpu/pred/gshare.cc
new file mode 100644
index 0000000..9291237
--- /dev/null
+++ b/src/cpu/pred/gshare.cc
@@ -0,0 +1,50 @@
+#include "cpu/pred/gshare.hh"
+
+#include "base/intmath.hh"
+#include "base/logging.hh"
+#include "base/trace.hh"
+#include "debug/Fetch.hh"
+
+namespace gem5
+{
+
+namespace branch_prediction
+{
+
+GShareBP::GShareBP(const GShareBPParams &params)
+    : BPredUnit(params),
+      localPredictorSize(params.localPredictorSize)
+{
+
+}
+
+void
+GShareBP::void updateHistories(ThreadID tid, Addr pc, bool uncond,
+                           bool taken, Addr target,
+                           const StaticInstPtr &inst, void * &bp_history)
+{
+// Place holder for a function that is called to update predictor history
+}
+
+
+bool
+GShareBP::lookup(ThreadID tid, Addr branch_addr, void * &bp_history)
+{
+    return false;
+}
+
+void
+GShareBP::update(ThreadID tid, Addr branch_addr, bool taken, void *&bp_history,
+                bool squashed, const StaticInstPtr & inst, Addr target)
+{
+
+}
+
+inline
+bool
+GShareBP::getPrediction(uint8_t &count)
+{
+    return false;
+}
+} // namespace branch_prediction
+} // namespace gem5
diff --git a/src/cpu/pred/gshare.hh b/src/cpu/pred/gshare.hh
new file mode 100644
index 0000000..61e1a74
--- /dev/null
+++ b/src/cpu/pred/gshare.hh
@@ -0,0 +1,94 @@
+#ifndef __CPU_PRED_GSHARE_PRED_HH__
+#define __CPU_PRED_GSHARE_PRED_HH__
+
+#include <vector>
+
+#include "base/sat_counter.hh"
+#include "base/types.hh"
+#include "cpu/pred/bpred_unit.hh"
+#include "params/GShareBP.hh"
+
+namespace gem5
+{
+
+namespace branch_prediction
+{
+
+/**
+ * Implements a gshare predictor, in which global history is XORed against
+ * bits from the PC. It uses the branch history to index into a table of
+ * counters. Global history is speculatively updated, and corrected during
+ * a squash.
+ */
+class GShareBP : public BPredUnit
+{
+  public:
+    /**
+     * Default branch predictor constructor.
+     */
+    GShareBP(const GShareBPParams &params);
+
+    // Overriding interface functions
+    /**
+     * Looks up the given address in the branch predictor and returns
+     * a true/false value as to whether it is taken.  Also creates a
+     * BPHistory object to store any state it will need on squash/update.
+     * @param branch_addr The address of the branch to look up.
+     * @param bp_history Pointer that will be set to the BPHistory object.
+     * @return Whether or not the branch is taken.
+     */
+    bool lookup(ThreadID tid, Addr pc, void * &bp_history) override;
+
+    /**
+     * Once done with the prediction, this funcion updates the path
+     * and global history. All branches call this function (including
+     * unconditional ones).
+     * @param tid The thread ID
+     * @param pc The branch PC to be updated
+     * @param uncond Is the branch unconditional?
+     * @param taken Did we take the branch?
+     * @param target The target of the branch
+     * @param bp_history The pointer set to an object
+     *   that has the branch predictor state associated
+     *   with the lookup
+     */
+    void updateHistories(ThreadID tid, Addr pc, bool uncond,
+                           bool taken, Addr target,
+                           const StaticInstPtr &inst, void * &bp_history) override;
+
+
+    /**
+     * Updates the branch predictor with the actual result of a branch.
+     * @param branch_addr The address of the branch to update.
+     * @param taken Whether or not the branch was taken.
+     * @param bp_history Pointer to the BPHistory object that was created
+     * when the branch was predicted.
+     * @param squashed is set when this function is called during a squash
+     * operation.
+     */
+    void update(ThreadID tid, Addr pc, bool taken,
+                void * &bp_history, bool squashed,
+                const StaticInstPtr & inst, Addr target) override;
+
+    /**
+     * Restores the global branch history on a squash.
+     * @param bp_history Pointer to the BPHistory object that has the
+     * previous global branch history in it.
+     */
+    void squash(ThreadID tid, void * &bp_history) override
+    { assert(bp_history == NULL); }
+
+  private:
+    /**
+     *  Returns the taken/not taken prediction given the value of the
+     *  counter.
+     *  @param count The value of the counter.
+     *  @return The prediction based on the counter value.
+     */
+    inline bool getPrediction(uint8_t &count);
+};
+
+} // namespace branch_prediction
+} // namespace gem5
+
+#endif // __CPU_PRED_GSHARE_PRED_HH__
